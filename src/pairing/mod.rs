pub mod pairing_mlkem;
pub mod pairing_ecies;

pub struct PairingContactMessageMaterial {
    mlkem_encapsulation_key: Vec<u8>,
    ecies_public_key: Vec<u8>,
}

pub struct PairingSecretKeyMaterial {
    mlkem_decapsulation_key: Option<Vec<u8>>,
    mlkem_shared_secret: Option<[u8; 32]>,
    ecies_secret_key: Vec<u8>,
}

pub struct PairingRequestMessageMaterial {
    mlkem_ciphertext: Vec<u8>,
    ecies_public_key: Vec<u8>,
}

pub type PairingSharedKey = [u8; 32];

pub fn contact_message() -> (PairingContactMessageMaterial, PairingSecretKeyMaterial) {
    let mut csprng = rand::rngs::OsRng;
    let (dk, ek) = pairing_mlkem::generate_encapsulation_key(&mut csprng);
    let (sk, pk) = pairing_ecies::generate_key(&mut csprng);
    
    (
        PairingContactMessageMaterial {
            mlkem_encapsulation_key: ek,
            ecies_public_key: pk,
        },
        PairingSecretKeyMaterial {
            mlkem_decapsulation_key: Some(dk),
            mlkem_shared_secret: None,
            ecies_secret_key: sk,
        }
    )
}

pub fn pairing_request_message(received: &PairingContactMessageMaterial) -> (PairingRequestMessageMaterial, PairingSecretKeyMaterial) {
    let mut csprng = rand::rngs::OsRng;

    let (ct, shared_key) = pairing_mlkem::encapsulate(&received.mlkem_encapsulation_key, &mut csprng);
    let (sk, pk) = pairing_ecies::generate_key(&mut csprng);

    (
        PairingRequestMessageMaterial {
            mlkem_ciphertext: ct,
            ecies_public_key: pk,
        },
        PairingSecretKeyMaterial {
            mlkem_decapsulation_key: None,
            mlkem_shared_secret: Some(shared_key),
            ecies_secret_key: sk,
        },
    )
}

/// to be invoked by the person who generated the pairing request message
pub fn finish_pairing_requestor(secrets: &PairingSecretKeyMaterial, received: &PairingContactMessageMaterial) -> PairingSharedKey {
    let mlkem_shared_key = secrets.mlkem_shared_secret.expect("missing mlkem shared key");
    let ecies_shared_key = pairing_ecies::derive_shared_key(&secrets.ecies_secret_key, &received.ecies_public_key);

    // xor and return
    let mut shared_key = [0u8; 32];
    for i in 0..32 {
        shared_key[i] = mlkem_shared_key[i] ^ ecies_shared_key[i];
    }

    shared_key
}

// to be invoked by the person who generated the contact message
pub fn finish_pairing_contactor(secrets: &PairingSecretKeyMaterial, received: &PairingRequestMessageMaterial) -> PairingSharedKey {
    let mlkem_dk = secrets.mlkem_decapsulation_key.as_ref().expect("missing mlkem decapsulation key");
    let mlkem_shared_key = pairing_mlkem::decapsulate(&mlkem_dk, &received.mlkem_ciphertext);
    let ecies_shared_key = pairing_ecies::derive_shared_key(&secrets.ecies_secret_key, &received.ecies_public_key);

    // xor and return
    let mut shared_key = [0u8; 32];
    for i in 0..32 {
        shared_key[i] = mlkem_shared_key[i] ^ ecies_shared_key[i];
    }

    shared_key
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_pairing() {
        // generated by Bob
        let (bob_contact, bob_secrets) = contact_message();
        let (alice_request, alice_secrets) = pairing_request_message(&bob_contact);

        let alice_shared_key = finish_pairing_requestor(&alice_secrets, &bob_contact);
        let bob_shared_key = finish_pairing_contactor(&bob_secrets, &alice_request);

        assert_eq!(alice_shared_key, bob_shared_key);
    }
}
